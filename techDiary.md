Título: Introducción de project_users y reestructuración de la relación usuario–proyecto–rol
Fecha: 26 de enero de 2026

En esta iteración se decidió refactorizar el modelo de relación entre usuarios, proyectos y roles mediante la introducción de una tabla intermedia denominada project_users. Esta tabla pasa a ser la única fuente de verdad para representar la pertenencia de un usuario a un proyecto y el rol que desempeña dentro de dicho proyecto. Como parte del cambio, se elimina la relación directa users.project_id, se descontinúa la tabla user_roles y se elimina el campo salt del modelo users, manteniendo intacto el modelo roles y su pertenencia a proyectos. El objetivo principal es preservar la semántica existente de roles y endpoints ya implementados, mientras se habilita una arquitectura más consistente y extensible.

Esta decisión se tomó porque el modelo anterior mezclaba responsabilidades y limitaba la evolución del sistema. Al tener project_id directamente en users, se asumía implícitamente que un usuario solo podía existir dentro de un único proyecto, lo cual introduce rigidez estructural y dificulta escenarios comunes como colaboración multi-proyecto, reutilización de cuentas o separación clara entre identidad y contexto. Además, la tabla user_roles asignaba roles de forma global al usuario, sin anclar dicha asignación al proyecto específico al que pertenecía el rol, lo que generaba ambigüedad conceptual y potenciales inconsistencias de datos.

La introducción de project_users resuelve estos problemas al modelar explícitamente la membresía: un usuario pertenece a un proyecto y, en ese contexto, tiene exactamente un rol asociado. Esto alinea el modelo de datos con la lógica real del dominio y con la forma en que ya estaban diseñados los roles (roles por proyecto). De esta manera, no se rompe el modelo roles ni los endpoints existentes, ya que los roles siguen siendo entidades propias del proyecto; lo que cambia es el punto donde se decide qué rol tiene un usuario dentro de ese proyecto.

Finalmente, la eliminación del campo salt del modelo users responde a una decisión de seguridad y simplificación técnica. En el contexto actual, el uso de algoritmos modernos de hashing (por ejemplo, bcrypt, argon2 o similares) hace innecesario almacenar el salt manualmente, ya que este se encuentra embebido en el propio hash. Mantener el campo añadía complejidad innecesaria y riesgo de mal uso sin aportar beneficios reales. En conjunto, estos cambios fortalecen la coherencia del modelo, reducen deuda técnica y preparan la base para una evolución más limpia del sistema en futuras iteraciones.
